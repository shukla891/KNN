# -*- coding: utf-8 -*-
"""credit_risk_assessment_KNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DFVTZHjQiFFywIikNA4RWKp8Z3BFk107
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px

dataset=pd.read_csv('credit_risk_dataset.csv')

dataset #dataframe

dataset.isnull().sum()

dataset=dataset.dropna(axis=0)
dataset.isnull().sum()

dataset.describe() #gives statistical data

#Scatterplot matrix
fig = px.scatter_matrix(dataset, dimensions=
["Age","Income","Employment_Length","Loan_Amount","Interest_Rate"],
labels={col:col.replace('_', ' ') for col in dataset.columns},height=900,
        color="Loan_Status", color_continuous_scale=px.colors.diverging.Tealrose)
fig.show()

#Removing outliers
dataset = dataset[dataset["Age"]<=100]
dataset = dataset[dataset["Employment_Length"]<=100]
dataset = dataset[dataset["Income"]<= 4000000]

#Percentage of non-default cases
dataset_0 = dataset[dataset.Loan_Status == 0].Loan_Status.count() / dataset.Loan_Status.count()
dataset_0

#Box plot
fig = px.box(dataset, x="loan_Grade", y="loan_percent_income", color="Loan_Status",
color_discrete_sequence=px.colors.qualitative.Dark24,
labels={col:col.replace('_', ' ') for col in dataset.columns},
category_orders={"loan_Grade":["A","B","C","D","E","F","G"]})
fig.update_layout(legend=dict(orientation="h", yanchor="bottom",
y=1.02, xanchor="right", x=1))
fig.show()

#Parallel category diagram
fig = px.parallel_categories(dataset, color_continuous_scale=px.colors.sequential.RdBu,
                             color="Loan_Status",
dimensions=['Home_Status', 'Loan_Intent', "loan_Grade", 'Historical_Default'],
                             labels={col:col.replace('_', ' ') for col in dataset.columns})
fig.show()

#One hot encoding of categorical variables
df = pd.get_dummies(data=dataset,columns=['Home_Status','Loan_Intent','loan_Grade','Historical_Default'])
# df=df.to_numpy()

#Train and test split
from sklearn.model_selection import train_test_split
Y = df['Loan_Status']
X = df.drop('Loan_Status',axis=1)
x_train, x_test, y_train, y_test = train_test_split(X, Y, random_state=0, test_size=.20)

from sklearn.neighbors import KNeighborsClassifier
classifier=KNeighborsClassifier(n_neighbors=151,metric="minkowski",p=2)
classifier.fit(x_train,y_train)

y_pred=classifier.predict(x_test)
y_pred_prob=classifier.predict_proba(x_test)
y_prob=y_pred_prob[:,1]
y_test=y_test.to_numpy()

print(np.concatenate((y_pred.reshape(len(y_pred),1),y_test.reshape(len(y_test),1)),1))

from sklearn.metrics import confusion_matrix,accuracy_score
cm=confusion_matrix(y_test,y_pred)
cm

accuracy_score(y_test,y_pred)

# ROC curve
from sklearn.metrics import roc_curve, roc_auc_score,brier_score_loss
false_positive_rate, true_positive_rate, threshold = roc_curve(y_test, y_prob)
print( roc_auc_score(y_test, y_prob))

plt.subplots (figsize=(5,5))
plt.title('Receiver Operating Characteristic')
plt.plot(false_positive_rate, true_positive_rate)
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.show()

# Reliability plot and brier score
from sklearn.calibration import calibration_curve
knn_y, knn_x = calibration_curve(y_test, y_prob, n_bins=10, normalize=True)
loss_knn = brier_score_loss(y_test, y_prob)
plt.plot(knn_x, knn_y, marker='o', label=f' Brier score = {str(round(loss_knn,3))}')
plt.ylabel("Actual probabilty")
plt.xlabel("Predicted probability")
plt.title("Reliability plot")
plt.rcParams['axes.titlesize'] = 10
plt.legend()
plt.show()